<!doctype html>
<html lang='en'>
  <head>
    <title>JavaScript/Functions</title>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <meta name='description' content='Fundamental resources about HTML5 & friends.'>
    <meta name='author' content='PictureElement (Marios Sofokleous)'>
    <meta name='theme-color' content='#007f7f'>
    <link rel='stylesheet' href='css/bootstrap.min.css' integrity='sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb' crossorigin='anonymous'>
    <link rel='stylesheet' href='css/style.css'>
    <link rel='manifest' href='manifest.json'>
    <script src='js/jquery.min.js' defer></script>
    <script src='js/popper.min.js' defer></script>
    <script src='js/bootstrap.min.js' defer></script>
    <script src='js/site.js' defer></script>
    <script src='js/run_prettify.js' defer></script>
    <script src='svg-with-js/js/fa-solid.js' defer></script>
    <script src='svg-with-js/js/fontawesome.js' defer></script>
  </head>
  <body>
    <!-- RETURN TO TOP BUTTON -->
    <button id='return-to-top' title='Return to top'><i style='color:white' class='fas fa-chevron-up'></i></button>
    <!-- SITE NAVIGATION -->
    <header class='navbar navbar-expand navbar-light bg-light flex-column flex-md-row'>
      <!-- LOGO -->
      <a class='navbar-brand' href='index.html'>
        <img src="images/logo-1x.png" srcset="images/logo-1x.png 1x, images/logo-2x.png 2x, images/logo-3x.png 3x, images/logo-4x.png 4x" class="d-inline-block align-top" alt="HTML5Tech logo">
      </a>
      <div class='flex-row'>
        <ul class='navbar-nav flex-row'>
          <li class='nav-item'>
            <a class='nav-link' href='#'>HTML</a>
          </li>
          <li class='nav-item'>
            <a class='nav-link' href='#'>CSS</a>
          </li>
          <li class='nav-item active'>
            <a class='nav-link' href='#'>JAVASCRIPT <span class='sr-only'>(current)</span></a>
          </li>
          <li class='nav-item'>
            <a class='nav-link' href='introduction.html'>JQUERY</a>
          </li>
        </ul>
      </div>
    </header>
    <div class='container-fluid'>
      <div class='row d-flex'>
        <div class='sidebar col-12 col-md-3 col-xl-2'>
          <div class='text-center'>
            <button class='more-btn btn btn-link d-md-none' type='button' data-toggle='collapse' data-target='#sidebarContent' aria-controls='sidebarContent' aria-label='Toggle sidebar navigation'>
              MORE
            </button>
          </div>
          <nav class='sidebar-links collapse' id='sidebarContent'>
            <div>
              <h5 class='sb-topic'>Basic JS</h5>
              <ol class='sb-list'>
                <li><a href='data-related.html'>Data-related</a></li>
                <li><a href='dom.html'>Document Object Model</a></li>
                <li><a href='object-related.html'>Object-related</a></li>
                <li><a href='flow-control.html'>Flow control</a></li>
                <li><a href='function-related.html'>Function-related</a></li>
                <li><a href='expressions-and-operators.html'>Expressions &amp; operators</a></li>
              </ol>
            </div>
            <div>
              <h5 class='sb-topic'>Object-Oriented JS</h5>
              <ol class='sb-list'>
                <li><a href='objects.html'>Objects</a></li>
                <li id='current'><a href='functions.html'>Functions</a></li> 
                <li><a href='classes.html'>Classes</a></li>
              </ol>
            </div>
          </nav>
        </div>
        <!-- MAIN -->
        <main class='col-12 col-md-9 col-xl-8'>
          <h1 class='text-left'>Functions</h1>
          <hr>
          <!-- CONTENT -->
          <div class='card content-card'>
            <div class='card-header' id='headingOne'>
              <button class='content-btn btn btn-link' type='button' data-toggle='collapse' data-target='#collapseOne' aria-controls='collapseOne' aria-label='Toggle content' aria-expanded='false'>
                Contents
              </button>
            </div>
            <div id='collapseOne' class='collapse' role='tabpanel' aria-labelledby='headingOne' data-parent='#accordion'>
              <div class='card-body'>
                <ol class='content-nav'>
                  <li><a href='#1'>First-class functions</a></li>
                  <li><a href='#2'>Functions are objects</a></li>
                  <li><a href='#3'>Higher-order functions</a></li>
                  <li>
                    <a href='#4'>Callback functions</a>
                    <ol>
                      <li><a href='#4-1'>Introduction</a></li>
                      <li><a href='#4-2'>'forEach()' method</a></li>
                      <li><a href='#4-3'>'map()' method</a></li>
                      <li><a href='#4-4'>'filter()' method</a></li>
                    </ol>
                  </li>
                  <li>
                    <a href='#5'>Function scope</a>
                    <ol>
                      <li><a href='#5-1'>Runtime scope</a></li>
                      <li><a href='#5-2'>Variable scope</a></li>
                      <li>
                        <a href='#5-3'>Closures</a>
                        <ol>
                          <li><a href='#5-3-1'>Definition</a></li>
                          <li><a href='#5-3-2'>Examples</a></li>
                          <li><a href='#5-3-3'>Garbage collection</a></li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <a href='#6'>Immediately-invoked function expressions</a>
                    <ol>
                      <li><a href='#6-1'>Function types</a></li>
                      <li><a href='#6-2'>Function declarations</a></li>
                      <li><a href='#6-3'>Function expressions</a></li>
                      <li><a href='#6-4'>Immediately-invoked function expressions</a></li>
                      <li><a href='#6-5'>Passing arguments to IIFE's</a></li>
                      <li><a href='#6-6'>IIFE's &amp; private scope</a></li>
                      <li><a href='#6-7'>What's true about IIFE's</a></li>
                      <li><a href='#6-8'>IIFE's, private scope &amp; event handling</a></li>
                      <li><a href='#6-9'>Summary</a></li>
                    </ol>
                  </li>
                </ol>
              </div>
            </div>
          </div>
          <!-- SECTION 1 -->
          <section>
            <h2>
              <a id='1' data-toggle='collapse' role='button' href='#accordion-1' aria-expanded='true' aria-controls='accordion-1'>
                First-class functions
              </a>
            </h2>
            <hr>
            <div id='accordion-1' class='collapse show'>
              <p>
                With first-class functions you can do just about anything that 
                you can do with other elements, such as numbers, strings, and 
                arrays. C-like programming languages do not support first-class 
                functions. However, scripting languages like Python and 
                JavaScript have built-in support.
              </p> 
              <p>Characteristics of first-class functions:</p>
              <ol>
                <li>Can be stored in variables</li>
                <li>Can be returned from a function</li>
                <li>Can be passed as arguments into another function</li>
              </ol>
            </div>
          </section>
          <!-- SECTION 2 -->
          <section>
            <h2>
              <a id='2' data-toggle='collapse' role='button' href='#accordion-2' aria-expanded='true' aria-controls='accordion-2'>
                Functions are objects
              </a>
            </h2>
            <hr>
            <div id='accordion-2' class='collapse show'>
              <p>
                In JavaScript functions can be treated as objects. A key 
                difference between a function and an object is that functions 
                can be called (i.e., invoked with ()), while regular objects 
                cannot.
              </p>
              <p>The following example is a proof that functions are indeed objects:</p>
              <pre class='prettyprint linenums'><code>function average(n1, n2, n3) {
    return (n1 + n2 + n3) / 3;
}

average.length; // 3
average.name; // 'average'</code></pre>
            </div>
          </section>
          <!-- SECTION 3 -->
          <section>
            <h2>
              <a id='3' data-toggle='collapse' role='button' href='#accordion-3' aria-expanded='true' aria-controls='accordion-3'>
                Higher-order functions
              </a>
            </h2>
            <hr>
            <div id='accordion-3' class='collapse show'>
              <p>
                A function that returns another function or takes other 
                functions as arguments is known as higher-order function. 
              </p>
              <pre class='prettyprint linenums'><code>function foo() {
    alert('Hello 1');
    return function() {
        alert('Hello 2');
    };
}

foo();
// Alerts 'Hello 1'

const innerFunction = foo();

innerFunction();
// Alerts 'Hello 2'

foo()(); 
// Alerts 'Hello 1' followed by 'Hello 2'

function hoo() {
    alert('Hello 1');
    function print() {
        alert('Hello 2');
    };
    return print();
}

hoo();
// Alerts 'Hello 1' followed by 'Hello 2'</code></pre>
            </div>
          </section>
          <!-- SECTION 4 -->
          <section>
            <h2>
              <a id='4' data-toggle='collapse' role='button' href='#accordion-4' aria-expanded='true' aria-controls='accordion-4'>
                Callback functions
              </a>
            </h2>
            <hr>
            <div id='accordion-4' class='collapse show'>
              <h3 id='4-1'>Introduction</h3>
              <p>
                A function that is passed as an argument into another function 
                is called a callback function. Callbacks are possible in JS 
                because functions are first-class functions.
              </p>
              <pre class='prettyprint linenums'><code>// Higher-order function
function foo(n, callback) {
    return n + callback();   
}

// Callback function
function hoo() {
    return 2;
}

foo(5, hoo); // 7</code></pre>
              <h3 id='4-2'>'forEach()' method</h3>
              <p>
                The <code>forEach()</code> method executes a provided function 
                once for each array element.
              </p>
              <pre class='prettyprint linenums'><code>// Array
const numArray = [1,2,3,4,5,6,7,8,9];

// Callback
function logIfEven(n) {
    if(n % 2 === 0) {
        console.log(n);
    }
}

// Method #1: forEach() invokes logIfEven() for each element in the array
numArray.forEach(function logIfEven(n) {
    if(n % 2 === 0) {
        console.log(n);
    }
});

//2
//4
//6
//8

// Method #2: forEach() invokes logIfEven() for each element in the array
numArray.forEach(logIfEven);

//2
//4
//6
//8</code></pre>
              <h3 id='4-3'>'map()' method</h3>
              <p>
                The <code>map()</code> method creates a new array with the 
                results of calling a provided function on every element in the 
                calling array. The method returns a new array; it does not 
                modify the original array.
              </p>
              <pre class='prettyprint linenums'><code>// Array
const numArray = [1,2,3,4,5,6,7,8,9];

// Callback
function logIfEven(n) {
    if(n % 2 === 0) {
        return n;
    }
}

// Method #1: map() invokes logIfEven() for each element in the array
const evenNumbers1 = numArray.map(function logIfEven(n) {
    if(n % 2 === 0) {
        return n;
    }
});

console.log(evenNumbers1); 

// [2,4,6,8]

// Method #2: map() invokes logIfEven() for each element in the array
const evenNumbers2 = numArray.map(logIfEven);

console.log(evenNumbers2); 

// [2,4,6,8]</code></pre>
              <pre class='prettyprint linenums'><code>/* Using map()
 *
 * Using the musicData array and map():
 *   - Return a string for each item in the array in the following format:
 *     &lt;album-name> by &lt;artist> sold &lt;sales> copies
 *   - Store the returned data in a new albumSalesStrings variable
 *
 * Note:
 *   - Do not delete the musicData variable
 *   - Do not alter any of the musicData content
 *   - Do not format the sales number; leave it as a long string of digits
 */

const musicData = [
    { artist: 'Adele', name: '25', sales: 1731000 },
    { artist: 'Drake', name: 'Views', sales: 1608000 },
    { artist: 'Beyonce', name: 'Lemonade', sales: 1554000 },
    { artist: 'Chris Stapleton', name: 'Traveller', sales: 1085000 },
    { artist: 'Pentatonix', name: 'A Pentatonix Christmas', sales: 904000 },
    { artist: 'Original Broadway Cast Recording', 
      name: 'Hamilton: An American Musical', sales: 820000 },
    { artist: 'Twenty One Pilots', name: 'Blurryface', sales: 738000 },
    { artist: 'Prince', name: 'The Very Best of Prince', sales: 668000 },
    { artist: 'Rihanna', name: 'Anti', sales: 603000 },
    { artist: 'Justin Bieber', name: 'Purpose', sales: 554000 }
];

const albumSalesStrings = musicData.map(function(item) {
    return item.name + ' by ' + item.artist + ' sold ' + item.sales + ' copies';
});

console.log(albumSalesStrings);

// ['25 by Adele sold 1731000 copies', 
//  'Views by Drake sold 1608000 copies', 
//  'Lemonade by Beyonce sold 1554000 copies', 
//  'Traveller by Chris Stapleton sold 1085000 copies', 
//  'A Pentatonix Christmas by Pentatonix sold 904000 copies', 
//  'Hamilton: An American Musical by Original Broadway Cast Recording sold 820000 copies', 
//  'Blurryface by Twenty One Pilots sold 738000 copies', 
//  'The Very Best of Prince by Prince sold 668000 copies', 
//  'Anti by Rihanna sold 603000 copies', 
//  'Purpose by Justin Bieber sold 554000 copies']</code></pre>
              <h3 id='4-4'>'filter()' method</h3>
              <p>
                The <code>filter()</code> method is similar to the 
                <code>map()</code> method. The difference is that the callback 
                function is used as a test, and only items in the array that 
                pass the test are included in the new array.
              </p>
              <pre class='prettyprint linenums'><code>const numArray = [1,2,3,4,5,6,7,8,9];

// filter() invokes the anonymous function for each element in the array
const evenNumbers = numArray.filter(function(n) {
    // Test if n is even. If n it's even, then n % 2 === 0 returns true and n
    // is included in the new array
    return n % 2 === 0;
});

console.log(evenNumbers); 

// [2,4,6,8]</code></pre>
              <pre class='prettyprint linenums'><code>/* Using filter()
 *
 * Using the musicData array and filter():
 *   - Return only album objects where the album's name is
 *     10 characters long, 25 characters long, or anywhere in between
 *   - Store the returned data in a new `results` variable
 *
 * Note:
 *   - Do not delete the musicData variable
 *   - Do not alter any of the musicData content
 */

const musicData = [
    { artist: 'Adele', name: '25', sales: 1731000 },
    { artist: 'Drake', name: 'Views', sales: 1608000 },
    { artist: 'Beyonce', name: 'Lemonade', sales: 1554000 },
    { artist: 'Chris Stapleton', name: 'Traveller', sales: 1085000 },
    { artist: 'Pentatonix', name: 'A Pentatonix Christmas', sales: 904000 },
    { artist: 'Original Broadway Cast Recording', 
      name: 'Hamilton: An American Musical', sales: 820000 },
    { artist: 'Twenty One Pilots', name: 'Blurryface', sales: 738000 },
    { artist: 'Prince', name: 'The Very Best of Prince', sales: 668000 },
    { artist: 'Rihanna', name: 'Anti', sales: 603000 },
    { artist: 'Justin Bieber', name: 'Purpose', sales: 554000 }
];

const results = musicData.filter(function(item) {
    return ((item.name.length &gt;= 10) &amp;&amp; (item.name.length &lt;= 25));
});

console.log(results);

//[{artist: 'Pentatonix', name: 'A Pentatonix Christmas', sales: 904000}, 
// {artist: 'Twenty One Pilots', name: 'Blurryface', sales: 738000},
// {artist: 'Prince', name: 'The Very Best of Prince', sales: 668000}]</code></pre>
            </div>
          </section>
          <!-- SECTION 5 -->
          <section>
            <h2>
              <a id='5' data-toggle='collapse' role='button' href='#accordion-5' aria-expanded='true' aria-controls='accordion-5'>
                Function scope
              </a>
            </h2>
            <hr>
            <div id='accordion-5' class='collapse show'>
              <h3 id='5-1'>Runtime scope</h3>
              <p>
                Runtime scope refers to the context of the function, or more 
                specifically, the set of variables available for the function 
                to use.
              </p>
              <p>A functions has access to the following:</p>
              <ol>
                <li>Function arguments</li>
                <li>Local variables</li>
                <li>Global variables</li>
                <li>Variables from its parent function's scope</li>
              </ol>
              <p>Consider the <code>child()</code> function below:</p>
              <pre class='prettyprint linenums'><code>// Global variable
    var global = 10;
    function parent() {
        // Variable from the parent scope
        let parentLocal = 20;
        return function child() {
            // Local variable
            let childLocal = 30;
            console.log(global + parentLocal + childLocal);
        }
    }
    parent()();

    // 60</code></pre>
              <p>
                The <code>child()</code> function has access to 
                <code>global</code>, <code>parentLocal</code>, and 
                <code>childLocal</code> variables.
              </p>
              <h3 id='5-2'>Variable scope</h3>
              <p><mark>Example 1</mark></p>
              <pre class='prettyprint linenums'><code>/*
var globalScoped = 100; // Available everywhere

function foo() {

    var functionScoped = 0; // Available inside function foo() ONLY

    for (let i = 0; i &lt; 10; i++) {

        let blockScoped = 2; // Available inside for loop ONLY

        functionScoped += 1;

        console.log('functionScoped:' + functionScoped + ' ' + blockScoped:' + blockScoped);
        // functionScoped:1 blockScoped:2
        // functionScoped:2 blockScoped:2
        // functionScoped:3 blockScoped:2
        // functionScoped:4 blockScoped:2
        // functionScoped:5 blockScoped:2
        // functionScoped:6 lockScoped:2
        // functionScoped:7 blockScoped:2
        // functionScoped:8 blockScoped:2
        // functionScoped:9 blockScoped:2
        // functionScoped:10 blockScoped:2
    }

    console.log('blockScoped:' + blockScoped);
    // Uncaught ReferenceError: blockScoped is not defined

    globalScoped += 1;

    console.log('globalScoped:' + globalScoped);
    // globalScoped:101

}

console.log(globalScoped);
// 101

console.log(functionScoped);
// Uncaught ReferenceError: functionScoped is not defined

console.log(blockScoped);
// Uncaught ReferenceError: blockScoped is not defined
*/</code></pre>
              <p><mark>Example 2</mark></p>
              <p>
                <code>var</code> has functional scope while <code>const</code> 
                and <code>let</code> have block scope.
              </p>
              <p>
                <code>const</code>, and <code>let</code> only remain in memory 
                while the for loop is running and are not longer accessible 
                once the for loop finishes.
              </p>
              <pre class='prettyprint linenums'><code>//----------------- Code 1 -----------------
for (var x = 0; x &lt; 10; x++) {}
console.log(x);
// 10

//----------------- Code 2 -----------------
var x;
for (x = 0; x &lt; 10; x++) {}
console.log(x);
// 10

//----------------- Code 3 -----------------

for (let y = 0; y &lt; 10; y++) {}
console.log(y);
// Uncaught ReferenceError: y is not defined</code></pre>
              <p><mark>Example 3</mark></p>
              <p>
                The JavaScript interpreter will always start off by looking 
                within its own local variables. If the variable isn't found, 
                the search will continue looking up what is called the 
                <strong>scope chain</strong>.
              </p>
              <pre class='prettyprint linenums'><code>function one() {
    two();
    function two() {
        three();
        function three() {
            // Function three's code here
        }
    }
}

one();</code></pre>
              <p>
                <code>three()</code> will not only have access to the variables 
                and functions 'above' it (i.e., those of <code>two()</code> and 
                <code>one()</code>) - <code>three()</code> will also have 
                access to any global variables defined outside 
                <code>one()</code>.
              </p>
              <p>We can visualize the <strong>scope chain</strong> as:</p>
              <ol>
                <li><code>three()</code> &lt;----- innermost scope</li>
                <li><code>two()</code></li>
                <li><code>one()</code></li>
                <li><code>window</code> (global object) &lt;----- outermost scope</li>
              </ol>
              <p>
                Generally, the order that the JS interpreter will search for 
                variables along the scope chain is:
              </p>
              <ol>
                <li>Local variables</li>
                <li>Parent function's variables</li>
                <li>Parent function's parent function's variables</li>
                <li>Global variables</li>
              </ol>
              <p><mark>Example 4</mark></p>
              <p>
                What happens when you create a variable with the same name as 
                another variable somewhere in the scope chain?
              </p>
              <p>
                JavaScript won't throw an error or otherwise prevent you from 
                creating that extra variable. In fact, the variable with local 
                scope will just temporarily 'shadow' the variable in the outer 
                scope. This is called <strong>variable shadowing</strong>. 
              </p>
              <pre class='prettyprint linenums'><code>const symbol = '¥';

function displayPrice(price) {
    const symbol = '$';
    console.log(symbol + price);
}

displayPrice('80');
// '$80'</code></pre>
              <p>
                Since the variable pointing to '$' is declared inside a 
                function (i.e., the 'inner' scope), it will override any 
                variables of the same name that belong in an outer scope -- 
                such as the global variable pointing to '¥''. As a result, 
                '$80' is displayed rather than '¥80'.
              </p>
              <p><mark>Example 5</mark></p>
              <p>
                When the following code runs, what is the output of the first, 
                second, and third logs to the console (respectively)?
              </p>
              <pre class='prettyprint linenums'><code>let n = 8;

function functionOne() {
    let n = 9;

    function functionTwo() {
        let n = 10;
        console.log(n);  // First log
    }

    functionTwo();

    console.log(n);  // Second log
}

functionOne();

console.log(n);  // Third log</code></pre>
              <p>The answer is: <mark>10, 9, 8</mark></p>
              <h3 id='5-3'>Closures</h3>
              <h4 id='5-3-1'>Definition</h4>
              <p>
                A closure is the combination of a function and the lexical 
                environment within which that function was declared.
              </p>
              <h4 id='5-3-2'>Examples</h4>
              <p><mark>Example 1</mark></p>
              <p>
                After <code>remember(5)</code> is executed and returned, the 
                returned function is still able to access number's value (i.e.,
                 5). <strong>Closures</strong> allow us to store a snapshot of 
                state at the time the function object is created. Closures 
                really shine in situations where a function is defined within 
                another function, allowing the nested function to access 
                variables outside of it.
              </p>
              <p>
                The nested anonymous function is still able to access its 
                parent function's scope (i.e. <code>number</code>) even after
                its parent function (i.e. <code>remember()</code>) has 
                returned.
              </p>
              <pre class='prettyprint linenums'><code>function remember(number) {
    return function() {
        return number;
    }
}

// Reference to the anonymous function
const returnedFunction = remember(5);

// The anonymous function is called and maintains access to its scope; that is, 
// all the variables it was able to access back when it was originally defined 
// (i.e. number)
console.log( returnedFunction() ); 
// 5</code></pre>
              <p><mark>Example 2</mark></p>
              <p>
                The <code>logger()</code> function is still able to access its 
                parent function's scope (i.e. <code>otherNumber</code>) even 
                after its parent function (i.e. <code>foo()</code>) has 
                returned. It's important to note that the state of 
                <code>otherNumber</code> is private and no method outside the 
                closure can alter it.
              </p>
              <pre class='prettyprint linenums'><code>const number = 5;
function foo() {
    const otherNumber = 3;
    function logger() {
        console.log(otherNumber);
    }
    return logger;
}

// Reference to logger() 
const result = foo();

// logger() is called and maintains access to its scope; that is, all the 
// variables it was able to access back when it was originally defined 
// (i.e. otherNumber)
result();
// 3

// The state of otherNumber is private
result.otherNumber;

// The state of otherNumber is private
otherNumber;</code></pre>
              <p><mark>Example 3 - Counter</mark></p>
              <p>
                The reference to the anonymous function is stored in 
                <code>counter</code>. As long as this reference exists, the 
                reference to <code>myCounter()</code> is maintained through the 
                anonymous function itself. <code>count</code> is retained and    
                can be modified. It's important to note that the state of 
                <code>count</code> is private and no method outside the closure 
                can alter it.
              </p>
              <pre class='prettyprint linenums'><code>function myCounter() {
    let count = 0;
    return function() {
        count += 1;
        return count;
    }
}

// Reference to the anonynous function
let counter = myCounter();

// The anonynous function is called and maintains access to its scope (i.e. count)
counter();
// 1

// The anonynous function is called and maintains access to its scope (i.e. count)
counter();
// 2

// The anonynous function is called and maintains access to its scope (i.e. count)
counter();
// 3

// The state of count is private
counter.count;
// undefined

// The state of count is private
count;
// Uncaught ReferenceError: count is not defined</code></pre>
              <p><mark>Example 4 - Expanded array</mark></p>
              <p>Declare a function named <code>expandArray()</code> that:</p>
              <ul>
                <li>Takes no arguments</li>
                <li>
                  Contains a single local variable, <code>myArray</code>, which 
                  points to <code>[1, 1, 1]</code>
                </li>
                <li>
                  Returns an anonymous function that directly modifies 
                  <code>myArray</code> by appending another <code>1</code> into 
                  it
                </li>
                <li>
                  The returned function then returns the value of 
                  <code>myArray</code>
                </li>
              </ul>
              <pre class='prettyprint linenums'><code>function expandArray() {
    const myArray = [1,1,1];
    return function() {
        myArray.push(1);
        return myArray;
    }
}

const array = expandArray();

array();
// [1, 1, 1, 1]

array();
// [1, 1, 1, 1, 1]

array();
// [1, 1, 1, 1, 1, 1]</code></pre>
              <h4 id='5-3-3'>Garbage collection</h4>
              <p>
                JavaScript manages memory with automatic garbage collection. 
                This means that when data is no longer referable (i.e., there 
                are no remaining references to that data available for 
                executable code), it is 'garbage collected' and will be 
                destroyed at some later point in time. This frees up the 
                resources (i.e., computer memory) that the data had once 
                consumed, making those resources available for re-use. As such, 
                referenceable variables in JavaScript are not garbage 
                collected!
              </p>
              <pre class='prettyprint linenums'><code>function myCounter() {
    let count = 0;
    return function() {
        count += 1;
        return count;
    }
}</code></pre>
              <p>
                <code>count</code> is not available for garbage colection since 
                the anonymous function retains access to the scope it was 
                created even after its parent (i.e. <code>myCounter()</code>) 
                has returned.
              </p>
            </div>
          </section>
          <!-- SECTION 6 -->
          <section>
            <h2>
              <a id='6' data-toggle='collapse' role='button' href='#accordion-6' aria-expanded='true' aria-controls='accordion-6'>
                Immediately-invoked function expressions
              </a>
            </h2>
            <hr>
            <div id='accordion-6' class='collapse show'>
              <h3 id='6-1'>Function types</h3>
              <ol>
                <li>Function Declarations</li>
                <li>Function Expressions</li>
                <li>Immediately-Invoked Function Expressions</li>
              </ol>
              <h3 id='6-2'>Function declarations</h3>
              <pre class='prettyprint linenums'><code>function foo() {
    return 'Hello World!';
}</code></pre>
              <h3 id='6-3'>Function expressions</h3>
              <pre class='prettyprint linenums'><code>// Anonymous
const myFunct = function() {
    return 'Hello World!';
};

// Named
const myFunct = function foo() {
    return 'Hello World!';
};</code></pre>
              <h3 id='6-4'>Immediately-invoked function expressions</h3>
              <p>
                A function that is called immediately after it is defined is 
                called an Immediately-Invoked Function Expression (IIFE)
              </p>
              <pre class='prettyprint linenums'><code>// Method #1

// Anonymous
(function() {
    return 'Hello World!';
})();

// Named
(function foo() {
  return 'Hello World!';
})();

// Method #2

// Anonymous
(function() {
    return 'Hello World!';
}());

// Named
(function foo() {
  return 'Hello World!';
}());</code></pre>
              <p>
                All we're doing is wrapping a function in parentheses, then 
                adding a pair of parentheses at the end of that to invoke it.
              </p>
              <h3 id='6-5'>Passing arguments to IIFE's</h3>
              <pre class='prettyprint linenums'><code>(function(name) {
    console.log(`Hello ${name}`);
})('Marios');

// Logs 'Hello Marios'
</code></pre>
              <p>
                The second pair of parentheses not only immediately executes 
                the function preceding it - it's also the place to put any 
                arguments that the function may need.
              </p>
              <p>
                <i class='fas fa-exclamation-triangle'></i>
                <code>(`Hello ${name}`)</code> is different from 
                <code>('Hello ${name}')</code>
              </p>
              <h3 id='6-6'>IIFE's &amp; private scope</h3>
              <pre class='prettyprint linenums'><code>const myFunction = (
    function() {
        const hi = 'Hi!';
        return function() {
            console.log(hi);
        }
    }
)();

myFunction();
// Hi!</code></pre>
              <p>
                An immediately-invoked function expression is used to 
                immediately run a function. This function runs and returns an
                anonymous function that is stored in the 
                <code>myFunction</code> variable. <code>myFunction</code> 
                maintains a private, mutable state that cannot be accessed 
                outside the function.
              </p>
              <h3 id='6-7'>What's true about IIFE's</h3>
              <ol>
                <li>IIFE's can be used to create private scope.</li>
                <li>IIFE's are closely related to scope and closures.</li>
              </ol>
              <h3 id='6-8'>IIFE's, private scope &amp; event handling</h3>
              <p>
                Let's check out another example of an IIFE -- this time in the 
                context of handling an event. Say that we want to create a 
                button on a page that alerts the user on 
                <strong>every other click</strong>. One way to begin doing this 
                would be to keep track of the number of times that the button 
                was clicked. But how should we maintain this data?
              </p>
              <p>
                We could keep track of the count with a variable that we 
                declare in the global scope (this would make sense if other 
                parts of the application need access to the count data). 
                However, an even better approach would be to enclose this data 
                in event handler itself.
              </p>
              <p>
                For one, this approach prevents us from polluting the global 
                with extra variables (and potentially variable name collisions). 
                What's more: if we use an IIFE, we can leverage a closure to 
                protect the count variable from being accessed externally! This 
                prevents any accidental mutations or unwanted side-effects from 
                inadvertently altering the count.
              </p>
              <pre class='prettyprint linenums'><code>&lt;html>
    &lt;body>

        &lt;button id='button'>Click me!&lt;/button>

        &lt;script>
            const button = document.getElementById('button');

            button.addEventListener('click', (function() {
                
                let count = 0;

                return function() {
                    
                    count += 1;

                    if (count === 2) {
                        alert('This alert appears every other press!');
                        count = 0;
                    }
                };
            })());
        &lt;/script>

    &lt;/body>
&lt;/html></code></pre>
              <p>
                The <code>count</code> variable is local to 
                <code>addEventListener()</code>. The returned function 
                maintains a reference to its parent's scope                    
                (i.e. <code>addEventListener()</code>). In other words, 
                <code>count</code> is available for the returned function to 
                use. As a result, we immediately invoke a function that returns
                that function. And since the returned function has access to 
                the internal variable, count, a private scope is created - 
                effectively protecting the data!
              </p>
              <p>Steps:</p>
              <ol>
                <li>Button is clicked</li>
                <li>Callback is invoked</li>
                <li>The returned function that has access to <code>count</code> is immediately invoked</li>
              </ol>
              <button type='button' style='margin-bottom:1rem;' class='btn btn-secondary' id='button'>Click me!</button>
              <script>
                // Grab the button element
                const button = document.getElementById('button');

                // Event listener for clicks (Pass an IIFE as a callback)
                button.addEventListener('click', (function() {
                      
                  // Local variable, available to the returned function
                  let count = 0;

                  return function() {
                          
                    count += 1;

                    if (count === 2) {
                      alert('This alert appears every other press!');
                      count = 0;
                    }
                  };
                })());
              </script>
              <h3 id='6-9'>Summary</h3>
              <p>
                Utilizing an <strong>IIFE alongside closures</strong> allows 
                for a private scope, which maintains privacy for variables 
                defined within them. And since less variables are created, an 
                IIFE will help to minimize pollution of the global environment, 
                hindering the chances of variable name collisions.
              </p>
              <p>
                All in all, if you simply have a one-time task (e.g., 
                initializing an application), an IIFE is a great way to get 
                something done without polluting your the global environment 
                with extra variables. Cleaning up the global namespace 
                decreases the chance of collisions with duplicate variable 
                names, after all.
              </p>
            </div>
          </section>
        </main>
        <!-- d-none d-xl-block d-xl-2: Hide the element for all screen sizes except on xlarge devices -->
        <div class='ad-space d-none d-xl-block col-xl-2'>
          <div class='text-center'>
            <h5>Ad1</h5>
            <img src='images/150x100.png' alt='advertisement'>
            <h5>Ad2</h5>
            <img src='images/150x100.png' alt='advertisement'>
            <h5>Ad3</h5>
            <img src='images/150x100.png' alt='advertisement'>
            <h5>Ad4</h5>
            <img src='images/150x100.png' alt='advertisement'>
            <h5>Ad5</h5>
            <img src='images/150x100.png' alt='advertisement'>
            <h5>Ad6</h5>
            <img src='images/150x100.png' alt='advertisement'>
          </div>
        </div>
      </div>
    </div> <!-- END OF CONTAINER -->
    <!-- FOOTER -->
    <footer class='text-center text-muted'>
      <div class='license'>
        <div>
          <a rel='license' href='https://creativecommons.org/licenses/by-sa/4.0/'><img width='100' alt='CC BY-SA 4.0 License' style='border-width:0' src='images/cc-by-sa-4.svg' /></a><br>Documentation is licensed under the <a rel='license' href='https://creativecommons.org/licenses/by-sa/4.0/'>CC BY-SA 4.0 License</a>.
        </div>
        <div>
          <a rel='license' href='https://www.gnu.org/licenses/agpl-3.0'><img width='80' alt='GNU AGPLv3 License' style='border-width:0' src='images/agpl-v3.svg' /></a><br><a href='https://github.com/PictureElement/html5tech'>Source code</a> is licensed under the <a rel='license' href='https://www.gnu.org/licenses/agpl-3.0'>AGPL v3 License</a>.
        </div>
      </div>
      <div class='copyright'>
        Design &amp; development by <a href='https://pictureelement.github.io/portfolio-2'>PictureElement</a> (Marios Sofokleous).
      </div>
    </footer>
  </body>
</html>
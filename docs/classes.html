<!doctype html>
<html lang="en">
  <head>
    <title>JavaScript/Classes</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Fundamental resources about HTML5 & friends.">
    <meta name="author" content="PictureElement (Marios Sofokleous)">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- Google fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Audiowide|Montserrat:200,200i,300,400|Roboto+Slab:100,300,400">
    <!-- Main stylesheet -->
    <link rel="stylesheet" href="css/style.css">
    
    <!-- Web app manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Scripts -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.6/umd/popper.min.js" defer></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" defer></script>
    <script src="js/site.js" defer></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?" defer></script>
  </head>
  <body>
    <!-- RETURN TO TOP BUTTON -->
    <button id="return-to-top" title="Return to top"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
    <!-- SITE NAVIGATION -->
    <header class="navbar navbar-expand navbar-light bg-light flex-column flex-md-row">
      <!-- Logo -->
      <a class="navbar-brand" href="index.html">HTML5<span>Tech</span></a>
      <!-- Items -->
      <div class="flex-row">
        <ul class="navbar-nav flex-row">
          <li class="nav-item">
            <a class="nav-link" href="#">HTML</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">CSS</a>
          </li>
          <li class="nav-item active">
            <a class="nav-link" href="#">JAVASCRIPT <span class="sr-only">(current)</span></a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="introduction.html">JQUERY</a>
          </li>
        </ul>
      </div>
      <!--
      <form class="flex-nowrap form-inline my-2 my-lg-0 ml-md-auto">
        <input class="form-control form-control-sm mr-2" type="search" placeholder="Search" aria-label="Search">
        <button class="btn btn-sm btn-outline-success my-2 my-sm-0" type="submit"><i class="fa fa-search" aria-hidden="true"></i></button>
      </form>
      -->
    </header>
    <div class="container-fluid">
      <div class="row d-flex">
        <div class="sidebar col-12 col-md-3 col-xl-2">
          <div class="text-center">
            <button class="more-btn btn btn-link d-md-none" type="button" data-toggle="collapse" data-target="#sidebarContent" aria-controls="sidebarContent" aria-label="Toggle sidebar navigation">
              MORE
            </button>
          </div>
          <nav class="sidebar-links collapse" id="sidebarContent">
            <div>
              <h5 class="sb-topic">Basic JS</h5>
              <ol class="sb-list">
                <li><a href="data-related.html">Data-related</a></li>
                <li><a href="dom.html">Document Object Model</a></li>
                <li><a href="object-related.html">Object-related</a></li>
                <li><a href="flow-control.html">Flow control</a></li>
                <li><a href="function-related.html">Function-related</a></li>
              </ol>
            </div>
            <div>
              <h5 class="sb-topic">Object-Oriented JS</h5>
              <ol class="sb-list">
                <li><a href="objects.html">Objects</a></li>
                <li><a href="functions.html">Functions</a></li> 
                <li id="current"><a href="classes.html">Classes</a></li>
              </ol>
            </div>
          </nav>
        </div>
        <!-- MAIN -->
        <main class="col-12 col-md-9 col-xl-8">
          <h1 class="text-left">Classes</h1>
          <hr>
          <!-- CONTENT -->
          <div class="card content-card">
            <div class="card-header" role="tab" id="headingOne">
              <button class="content-btn btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-controls="collapseOne" aria-label="Toggle content" aria-expanded="false">
                Contents
              </button>
            </div>
            <div id="collapseOne" class="collapse" role="tabpanel" aria-labelledby="headingOne" data-parent="#accordion">
              <div class="card-body">
                <ol class="content-nav">
                  <li>
                    <a href="#1">Constructor functions</a>
                    <ol>
                      <li><a href="#1-1">Introduction</a></li>
                      <li><a href="#1-2">Creating objects</a></li>
                      <li><a href="#1-3">Ctor functions can have parameters</a></li>
                      <li><a href="#1-4">Seeing an object's ctor</a></li>
                    </ol>
                  </li>
                  <li>
                    <a href="#2">"this" keyword</a>
                    <ol>
                      <li><a href="#2-1">In object methods</a></li>
                      <li><a href="#2-2">In ctor functions</a></li>
                      <li>
                        <a href="#2-3">Setting our own "this"</a>
                        <ol>
                          <li><a href="#2-3-1">"call()" method</a></li>
                          <li><a href="#2-3-2">"apply()" method</a></li>
                          <li><a href="#2-3-3">"bind()" method</a></li>
                          <li><a href="#2-3-4">Examples</a></li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <a href="#3">Prototypal inheritance</a>
                    <ol>
                      <li><a href="#3-1">Introduction</a></li>
                      <li><a href="#3-2">Adding methods to the ctor funtion's prototype</a></li>
                      <li><a href="#3-3">Replacing the prototype</a></li>
                      <li><a href="#3-4">Standard built-in objects &amp; their prototypes</a></li>
                      <li>
                        <a href="#3-5">Checking an object's properties</a>
                        <ol>
                          <li><a href="#3-5-1">Introduction</a></li>
                          <li><a href="#3-5-2">"hasOwnProperty()" method</a></li>
                          <li><a href="#3-5-3">"isPrototypeOf()" method</a></li>
                          <li><a href="#3-5-4">"Object.getPrototypeOf()" method</a></li>
                          <li><a href="#3-5-5">"constructor" property</a></li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </div>
            </div>
          </div>
          <!-- SECTION 1 -->
          <section>
            <h2 id="1" data-toggle="collapse" role="button" href="#accordion-1" aria-expanded="true" aria-controls="accordion-1">
              Constructor functions
            </h2>
            <hr>
            <div id="accordion-1" class="collapse show">
              <h3 id="1-1">Introduction</h3>
              <pre class="prettyprint linenums"><code>// Ctor function
function Automobile() {
    this.brand = 'BMW';
}</code></pre>
              <p>
                Rather than declaring local variables, constructor functions 
                persist data with the <code>this</code> keyword. The above 
                function will add a <code>brand</code> property to any object 
                that it creates, and assigns it a default value of 
                <code>BMWM</code>. Ctor functions <em>should not</em> have an 
                explicit return value. The name of a ctor function, should be 
                written with the first letter capitalized to visually 
                distinguish it from a regular function. 
              </p>
              <h3 id="1-2">Creating objects</h3>
              <pre class="prettyprint linenums"><code>// Using the JS keyword 'new'
let car1 = new Automobile();

// Using an object literal
let car2 = { brand: 'BMW'};</code></pre>
              <h3 id="1-3">Ctor functions can have parameters</h3>
              <pre class="prettyprint linenums"><code>// Ctor function
function Automobile(model, color) {
    this.brand = 'Audi';
    this.model = model;
    this.color = color;
    this.description = function () {
        console.log(`${this.brand} ${this.model} ${this.color} car`);
    }
}

// Create objects
const car1 = new Automobile('TT', 'red');
const car2 = new Automobile('A4', 'green');

console.log(car1.model);
// TT

console.log(car2.color);
// green

car1.description();
// Audi TT red car

car2.description();
// Audi A4 green car</code></pre>
              <p>
                We can use the same constructor function to create as many 
                objects as we'd like!
              </p>
              <h3 id="1-4">Seeing an object's ctor</h3>
              <p>
                What if we want to see if an object was created with a 
                constructor function in the first place? We can use the 
                <code>instanceOf</code> to give us some insight.
              </p>
              <pre class="prettyprint linenums"><code>// Ctor function
function Person(name) {
    this.name = name;
}

// Object
const woman = new Person('Mary');

// Check type
typeof woman;
// object

// Check if object is an instance of the 'Person' ctor function
woman instanceof Person;
// true</code></pre>
            </div>
          </section>
          <!-- SECTION 2 -->
          <section>
            <h2 id="2" data-toggle="collapse" role="button" href="#accordion-2" aria-expanded="true" aria-controls="accordion-2">
              "this" keyword
            </h2>
            <hr>
            <div id="accordion-2" class="collapse show">
              <h3 id="2-1">In object methods</h3>
              <pre class="prettyprint linenums"><code>// Create object
const man = {
    name: 'Marios',
    sayHello: function () {
        return 'Hello';
    },
    greetings: function () {
        console.log(`${this.sayHello()} from ${this.name}`);
    }
};

// Call method
man.greetings();
// Hello from Marios</code></pre>
              <p>
                Using <code>this</code>, methods can access and manipulate an 
                object's properties. In the above example, 
                <code>greetings()</code> can use <code>this</code> to access 
                the <code>man</code> object, which contains the 
                <code>sayHello()</code> method.
              </p>
              <h3 id="2-2">In ctor functions</h3>
              <pre class="prettyprint linenums"><code>// Ctor function
function Person(name) {
    this.name = name;
    this.sayHello = function () {
        return 'Hello';
    };
    this.greetings = function () {
        console.log(`${this.sayHello()} from ${this.name}`);
    };
}

// Create object
const man = new Person('Marios');

// Call method
man.greetings();
// Hello from Marios</code></pre>
              <p> 
                Calling the ctor function with the <code>new</code> keyword 
                sets he value of <code>this</code> to the newly-created object.
              </p>
              <h3 id="2-3">Setting our own "this"</h3>
              <h4 id="2-3-1">"call()" method</h4>
              <pre class="prettyprint linenums"><code>function.call(thisArg, arg1, arg2, ...)</code></pre>
              <dl>
                <dt><code>thisArg</code></dt>
                <dd>Value to be set as <code>this</code></dd>
                <dt><code>arg1, arg2, ..., argn</code></dt>
                <dd>Arguments of <code>function()</code></dd>
              </dl>
              <p>
                Using <code>call()</code> to invoke a method, allows us to 
                "borrow" a method from one object and then use it for another 
                object!
              </p>
              <pre class="prettyprint linenums"><code>
// Create object
const car1 = {
    brand: "Audi",
    model: "A4",
    color: "blue",
    describe: function () {
        // 'this' refers to the 'car1' object
        console.log(`${this.brand} ${this.model} ${this.color} car`); 
    }
};

// Create object
const car2 = {
    brand: "VW",
    model: "Golf",
    color: "red"
};

car1.describe();
// Audi A4 blue car

car2.describe();
// Uncaught TypeError: car2.describe is not a function

car1.describe.call(car2);
// VW Golf red car</code></pre>
              <h4 id="2-3-2">"apply()" method</h4>
              <pre class="prettyprint linenums"><code>function.apply(thisArg, [argsArray])</code></pre>
              <dl>
                <dt><code>thisArg</code></dt>
                <dd>Value to be set as <code>this</code></dd>
                <dt><code>[argsArray]</code></dt>
                <dd>Arguments of <code>function()</code></dd>
              </dl>
              <div>
                <p class="warning align-middle">
                  <strong>Note</strong>: While the syntax of this function is 
                  almost identical to that of <code>call()</code>, the 
                  fundamental difference is that <code>call()</code> accepts 
                  an argument list, while <code>apply()</code> accepts a single 
                  array of arguments.
                </p>
              </div>
              <h4 id="2-3-3">"bind()" method</h4>
              <p>
                The value of <code>this</code> has some potential scope issues 
                when callback functions are involved, and things can get a bit 
                tricky.
              </p> 
              <pre class="prettyprint linenums"><code>// Function
function foo(callback) {
    // If a function is simply invoked, 'this' is set to 'window'
    callback();
    callback();
}

// Object
const dog = {
    age: 5,
    grow: function() {
        this.age += 1;
    }
};

dog.grow();

dog.age;
// 6

// Function call: Doesn't work as expected
foo(dog.grow);

// You may have expected the value to be 8
dog.age;
// 6</code></pre>
              <p>
                <code>foo()</code> calls <code>callback()</code> as a function 
                rather than a method. As a result, <code>this</code> refers to 
                the global object and not the <code>dog</code> object.
              </p>
              <div>
                <p class="danger align-middle">
                  <strong>Note</strong>: If a constructor function is called 
                  with the <code>new</code> operator, the value of 
                  <code>this</code> is set to the newly-created object. If a 
                  method is invoked on an object, <code>this</code> is set to 
                  that object itself. And if a function is simply invoked, 
                  <code>this</code> is set to the global object: 
                  <code>window</code>.
                </p>
              </div>
              <p>
                So how can we make sure that <code>this</code> is preserved? 
                One way to resolve this issue is to use an <strong>anonymous 
                closure</strong> to close over the <code>dog</code> object:
              </p>
              <pre class="prettyprint linenums"><code>// Function
function foo(callback) {
    callback();
    callback();
}

// Object
const dog = {
    age: 5,
    grow: function() {
        this.age += 1;
    }
};

// Function call
foo(function () { 
    // If a method is invoked on an object, 'this' is set to that object itself
    dog.grow(); 
});

dog.age;
// 7</code></pre>
              <p>
                Since this is such a common pattern, JavaScript provides an 
                alternate and less verbose approach: the <code>bind()</code> 
                method.
              </p>
              <p>The <code>bind()</code> Method</p>
              <pre class="prettyprint linenums"><code>function.bind(thisArg [,arg1[,arg2[,argN]]])</code></pre>
              <dl>
                <dt><code>thisArg</code></dt>
                <dd>Value to be set as <code>this</code></dd>
                <dt><code>arg1[,arg2[,argN]]]</code></dt>
                <dd>Optional. A list of arguments to be passed to the new function.</dd>
              </dl>
              <p>
                Regarding the previous example, an alternative and less verbose 
                approach to preserved <code>this</code>, is to explicitly set 
                the <code>dog.grow()</code>'s <code>this</code> value to the 
                <code>dog</code> object:
              </p>
              <pre class="prettyprint linenums"><code>// Function
function foo(callback) {
    // If a function is simply invoked, 'this' is set to 'window', unless the 
    // function's 'this' value is explicitly set to another value
    callback();
    callback();
}

// Object
const dog = {
    age: 5,
    grow: function() {
        this.age += 1;
    }
};

// A copy of 'dog.grow()' with specified 'this' value
const growCopy = dog.grow.bind(dog);

// Function call
foo(growCopy);

dog.age;
// 7</code></pre>
              <h4 id="2-3-4">Examples</h4>
              <p><mark>Example 1: bind()</mark></p>
              <p>Consider the following <code>driver</code> and <code>car</code> objects:</p>
              <pre class="prettyprint linenums"><code>const driver = {
    name: 'Danica',
    displayName: function () {
        console.log(`Name: ${this.name}`);
    }
};

const car = {
    name: 'Fusion'
};</code></pre>
              <p>
                Write an expression using <code>bind()</code> that allows us to 
                "borrow" the <code>displayName()</code> method from 
                <code>driver</code> for the <code>car</code> object to use:
              </p>
              <pre class="prettyprint linenums"><code>const displayNameCopy = driver.displayName.bind(car);

displayName();
// Name: Fusion</code></pre>
              <p><mark>Example 2: call() &amp; apply()</mark></p>
              <pre class="prettyprint linenums"><code>// Create object
const cow = {
    name: "Dolly"
};

// Create function
function sayHello(message) {
    console.log(this);
    console.log(`${message}, ${this.name}`);
}

// 'this' refers to 'window' object
sayHello('Hello from');
// Window {...} 
// Hello from, 

// 'this' refers to 'cow' object
sayHello.call(cow, 'Hello from');
// {name: "Dolly"} 
// Hello from, Dolly

// 'this' refers to 'cow' object
sayHello.apply(cow, ['Hello from']);
// {name: "Dolly"} 
// Hello from, Dolly</code></pre>
              <p><mark>Example 3: call()</mark></p>
              <p>
                Consider the following <code>Andrew</code> and 
                <code>Richard</code> objects:
              </p>
              <pre class="prettyprint linenums"><code>const Andrew = {
    name: 'Andrew',
    introduce: function () {
        console.log(`Hi, my name is ${this.name}!`);
    }
};

const Richard = {
    name: 'Richard',
    introduce: function () {
        console.log(`Hello there! I'm ${this.name}.`);
    }
};</code></pre>
              <p>
                <i>Question:</i> When 
                <code>Richard.introduce.call(Andrew);</code> is executed, what 
                is logged to the console?<br>
                <i>Answer:</i> <code>'Hello there!' I'm Andrew.'</code>
              </p>
              <p><mark>Example 4: call()</mark></p>
              <p>Consider the following:</p>
              <pre class="prettyprint linenums"><code>const andrew = {
    name: 'Andrew'
};

function introduce(language) {
    console.log(`I'm ${this.name} and my favorite programming language is ${language}.`);
}</code></pre>
              <p>
                Write an expression that uses the <code>call()</code> method to
                produce the message: <code>'I'm Andrew and my favorite 
                programming language is JavaScript.'</code>
              </p>
              <p><strong>Answer</strong>: <code>introduce.call(andrew, 'JavaScript');</code></p>
            </div>
          </section>
          <!-- SECTION 3 -->
          <section>
            <h2 id="3" data-toggle="collapse" role="button" href="#accordion-3" aria-expanded="true" aria-controls="accordion-3">
              Prototypal inheritance
            </h2>
            <hr>
            <div id="accordion-3" class="collapse show">
              <h3 id="3-1">Introduction</h3>
              <p>Consider the following example:</p>
              <pre class="prettyprint linenums"><code>// Ctor function
function Cat(name, age) {
    this.name = name;
    this.age = age;
    this.meow = function () {
        console.log(`Meow! My name is ${this.name}`);
    }
}

// Create objects
const keira = new Cat('Keira', 3);
const bob = new Cat('Bob', 4);

keira.meow();
// 'Meow! My name is Keira'

bob.meow();
// 'Meow! My name is Bob'</code></pre>
              <p>
                Let's go ahead and remove <code>meow()</code> from the 
                <code>Cat</code> ctor and add it to its prototype:
              </p>
              <pre class="prettyprint linenums"><code>// Ctor function
function Cat(name, age) {
    this.name = name;
    this.age = age;
}

// Create objects
const keira = new Cat('Keira', 3);
const bob = new Cat('Bob', 4);  

// Ctor's function prototype: Note that even after we make the new objects, 
// 'keira' &amp; 'bob', we can still add properties to Cat's prototype 
Cat.prototype.meow = function () {
    console.log(`Meow! My name is ${this.name}`);
};  

keira.meow();
// 'Meow! My name is Keira'

bob.meow();
// 'Meow! My name is Bob'</code></pre>
              <p>
                When we called <code>meow()</code> on <code>keira</code> (and 
                <code>bob</code> likewise), the JS engine will look first at the 
                object's own properties to find a name that matches 
                <code>meow()</code>. Since the method isn't directly defined in 
                the object, it will then look at the object's ctor prototype 
                for a match.
              </p>
              <div>
                <p class="warning align-middle"> 
                  <strong>Note</strong>: In cases where the property doesn't 
                  exist in the prototype, the JS engine will continue looking up 
                  the <strong>prototype chain</strong>. At the very end of the 
                  chain is the <code>Object()</code> object, or the top-level 
                  parent. If the property still cannot be found, the property is 
                  <code>undefined</code>.
                </p>
              </div>
              <div>
                <p class="warning align-middle">
                  <strong>Note</strong>: Each function has a 
                  <code>prototype</code> property, which is really just an 
                  object. All objects created by a ctor function keep a 
                  reference to that <code>prototype</code> and can use its 
                  properties as their own! 
                </p>
              </div>
              <h3 id="3-2">Adding methods to the ctor funtion's prototype</h3>
              <p>
                To <strong>save memory</strong> and 
                <strong>keep things DRY</strong>, we can add methods to the 
                ctor function's <code>prototype</code>.
              </p>
              <p>Consider the following two code snippets below:</p>
              <pre class="prettyprint linenums"><code>// A
function Cat(name) {
    this.name = name;
    this.meow = function () {
        console.log(`Meow! My name is ${this.name}`);
    }
}</code></pre>
              <pre class="prettyprint linenums"><code>// B
function Cat(name) {
    this.name = name;
}

Cat.prototype.meow = function () {
    console.log(`Meow! My name is ${this.name}`);
}</code></pre>
              <p>
                Let's say that we want to define a method that can be invoked on 
                instances (objects) of the <code>Cat</code> ctor function (we'll 
                be instantiating at least 101 of them!).
              </p>
              <p>
                <i>Question:</i> Which of the preceding two approaches 
                is optimal?
              </p>
              <p>
                <i>Answer:</i> (B) is optimal, because the function 
                that <strong>meow</strong> points to does not need to be 
                recreated each time a <code>Cat</code> object is created.
              </p> 
              <h3 id="3-3">Replacing the prototype</h3>
              <pre class="prettyprint linenums"><code>// Ctor function
function Parrot(name) {
    this.name = name;
}

// Create objects
const charly = new Parrot("Charly");
const ricky = new Parrot("Ricky");

// Even after we make the new objects, 'charly' &amp; 'ricky', we can still add 
// properties to the prototype
Parrot.prototype.speak = function () {
    console.log("Hellooooooo");
};

charly.speak();
// 'Hellooooooo'

ricky.speak();
// 'Hellooooooo'</code></pre>
              <p>
                Now let's replace <code>Parrot</code>'s <code>prototype</code>
                As we can see, the previous objects don't have access to the 
                updated prototype's properties; they just retain their secret 
                link to the old prototype:
              </p>
              <pre class="prettyprint linenums"><code>// Replace 'prototype'
Parrot.prototype = {
    isCockatoo: true,
    color: 'white'
};

console.log(charly.color);
// undefined

console.log(ricky.isCockatoo);
// undefined</code></pre>
              <p>
                As it turns out, any new <code>Parrot</code> objects created 
                moving forward will use the updated prototype:
              </p>
              <pre class="prettyprint linenums"><code>// Create object
const erik = new Parrot("Erik");

erik.speak();
// TypeError: erik.speak is not a function

console.log(erik.color);
// 'white'

console.log(erik.isCockatoo)
// true</code></pre>
              <h3 id="3-4">Standard built-in objects &amp; their prototypes</h3>
              <p>Instances (objects) inherit from their ctor's prototype.</p>
              <p>Ctors and their respective prototypes:</p>
              <ul>
                <code>Array/Array.prototype</code>
                <code>String/String.prototype</code>
                <code>Number/Number.prototype</code>
                <code>Boolean/Boolean.prototype</code>
                <code>Date/Date.prototype</code>
              </ul>
              <pre class="prettyprint linenums"><code>// Create 'Array' objects
var myArray1 = [1, 2, 3];
var myArray2 = ['a', 'b', 'c'];

// 'push()' is defined in the Array.prototype
myArray1.push(4);
// [1, 2, 3, 4]

// 'push()' is defined in the Array.prototype
myArra2.push('d');
// ['a', 'b', 'c', 'd']</code></pre>
              <p>
                We can change the constructor's prototype object 
                (<code>Array.prototype</code>) to make changes to all 
                <code>Array</code> instances (objects). For example, you can add 
                new methods and properties to extend all <code>Array</code> 
                objects.
              </p>
              <pre class="prettyprint linenums"><code>
Array.prototype.myReverse = function () {
    var res = new Array;
    for(let i = this.length - 1; i >= 0; i--) {
        res.push(this[i]);
    }
    return res;
}

myArray1 = myArray1.myReverse();
// [4, 3, 2, 1]

myArray2 = myArray2.myReverse();
// ['d', 'c', 'b', 'a']</code></pre>
              <h3 id="3-5">Checking an object's properties</h3>
              <h4 id="3-5-1">Introduction</h4>
              <p>
                If an object doesn't have a particular property of its own, it 
                can access one somewhere along the prototype chain. In this 
                section, we'll cover a few useful methods that can help us 
                determine where a particular property is coming from.
              </p>
              <h4 id="3-5-2">"hasOwnProperty()" method</h4>
              <p>
                The <code>hasOwnProperty()</code> method returns a boolean 
                indicating whether the object has the specified property as own
                (not inherited) property.
              </p>
              <pre class="prettyprint linenums"><code>// Ctor
function Foo() {
    // Own property
    this.property1 = "1234";
}

// Inherited property
Foo.prototype.property2 = "5678";

// Crteate object
const myFoo = new Foo();

console.log(myFoo.hasOwnProperty('property1'));
// true

console.log(myFoo.hasOwnProperty('property2'));
// false</code></pre>
              <h4 id="3-5-3">"isPrototypeOf()" method</h4>
              <p>
                The <code>isPrototypeOf()</code> method checks if an object 
                exists in another object's prototype chain. Using this method, 
                you can confirm if a particular object serves as the prototype 
                of another object. 
              </p>
              <pre class="prettyprint linenums"><code>// Prototype
const motorVehicle = {
    move: function() {
        console.log("I am moving!");
    }
}

// Ctor function
function Car(model, displacement) {
    this.model = model;
    this.displacement = displacement;
}

// Replace Car's prototype
Car.prototype = motorVehicle;

// Create object
const myCar = new Car('Suzuki Jimny', 1.3);

// model: own property
console.log(myCar.model);
// "Suzuki Jimny"

// move(): inherited property
myCar.move();
// I am moving!

// The prototype of a 'Car' instance is the 'motorVehicle' object
console.log(motorVehicle.isPrototypeOf(myCar));
// true</code></pre>
              <div>
                <p class="warning align-middle">
                  <strong>Note</strong>: <code>isPrototypeOf()</code> works 
                  well, but keep in mind that in order use it, you must have 
                  that prototype object at hand in the first place.
                </p>
              </div>
              <h4 id="3-5-4">"Object.getPrototypeOf()" method</h4>
              <p>
                The <code>Object.getPrototypeOf()</code> method returns the 
                prototype of the specified object.
              </p>
              <p>Continuing from the previous example:</p>
              <pre class="prettyprint linenums"><code>const myPrototype = Object.getPrototypeOf(myCar);

console.log(myPrototype);
// {move: ƒ}</code></pre>
              <p>
                Let's consider another example and let's say that we create the 
                following object, <code>capitals</code>, using the 
                <strong>literal notation</strong>:
              </p>
              <pre class="prettyprint linenums"><code>const capitals = {
    California: 'Sacramento',
    Washington: 'Olympia',
    Oregon: 'Salem',
    Texas: 'Austin'
};</code></pre>
              <p>
                <i>Question:</i> What is returned when 
                <code>Object.getPrototypeOf(capitals);</code> is executed?
              </p>
              <p>
                <i>Solution:</i> Because the object was created using 
                <strong>literal notation</strong>, its constructor is the 
                built-in <code>Object()</code> constructor function which in 
                turn maintains a reference to <code>Object.prototype</code>
              </p>
              <p>
                <i>Answer:</i> A reference to <code>Object()</code>'s 
                prototype.
              </p>
              <pre class="prettyprint linenums"><code>Object.getPrototypeOf(capitals) === Object.prototype
// true</code></pre>
              <h4 id="3-5-5">"constructor" property</h4>
              <p>
                Each time an object is created, a special property is assigned 
                to it under the hood: <code>constructor</code>. Accessing an 
                object's <code>constructor</code> property returns a reference 
                to the constructor function that created that object in the 
                first place! 
              </p>
              <pre class="prettyprint linenums"><code>// Ctor
function Longboard() {
    this.material = 'bamboo';
}

// Create object
const board = new Longboard();

// Print the ctor function that created the 'board' object
console.log(board.constructor);
// ƒ Longboard() {
//     this.material = 'bamboo';
// }</code></pre>
              <p>
                Keep in mind that if an object was created using <strong>literal 
                notation</strong>, its constructor is the built-in 
                <code>Object()</code> constructor function!
              </p>
              <pre class="prettyprint linenums"><code>const foo = {
    description: "foo object",
    message: "hello world!"
}

console.log(foo.constructor);
// ƒ Object() { [native code] }</code></pre>
            </div>
          </section>
          <!-- SECTION 4 -->
          <section>
            <h2 data-toggle="collapse" role="button" href="#accordion-4" aria-expanded="true" aria-controls="accordion-4">
              
            </h2>
            <hr>
            <div id="accordion-4" class="collapse show">
              
            </div>
          </section>
        </main>
        <!-- d-none d-xl-block d-xl-2: Hide the element for all screen sizes except on xlarge devices -->
        <div class="ad-space d-none d-xl-block col-xl-2">
          <div class="text-center">
            <h5>Ad1</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
            <h5>Ad2</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
            <h5>Ad3</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
            <h5>Ad4</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
            <h5>Ad5</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
            <h5>Ad6</h5>
            <a href="https://placeholder.com"><img src="https://via.placeholder.com/150x100"></a>
          </div>
        </div>
      </div>
    </div> <!-- END OF CONTAINER -->

    <!-- FOOTER -->
    <footer class="text-center text-muted">
        <div class="license">
          <div>
              <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img width="100px" alt="CC BY-SA 4.0 License" style="border-width:0" src="https://img.shields.io/badge/License-CC%20BY--SA%204.0-lightgrey.svg" /></a><br>Documentation is licensed under the <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0 License</a>.
          </div>
          <div>
              <a rel="license" href="https://www.gnu.org/licenses/agpl-3.0"><img width="80px" alt="GNU AGPLv3 License" style="border-width:0" src="https://img.shields.io/badge/License-AGPL%20v3-blue.svg" /></a><br><a href="https://github.com/PictureElement/html5tech">Source code</a> is licensed under the <a rel="license" href="https://www.gnu.org/licenses/agpl-3.0">AGPL v3 License</a>.
          </div>
        </div>
        <div class="copyright">
            Design &amp; development by 
            <a href="https://pictureelement.github.io/portfolio-2">
            PictureElement</a> (Marios Sofokleous).
        </div>
    </footer>
    <script>
      /* Register the service worker */
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
          navigator.serviceWorker.register('./sw.js').then(function(registration) {
            // Registration was successful
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          }, function(err) {
            // registration failed :(
            console.log('ServiceWorker registration failed: ', err);
          });
        });
      }
    </script>
  </body>
</html>